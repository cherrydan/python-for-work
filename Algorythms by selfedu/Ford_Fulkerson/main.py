#!/usr/bin/python3

# -*- coding: utf-8 -*-

from Ford_Fulkerson import *



if __name__ == '__main__':
    j = init
    while j != -1:
        k = init  # стартовая вершина
        T = [Tinit]  # метки маршрута
        S = {init}  # множество просморенных вершин

        while k != end:  # пока не дошли до стока
            j = get_max_vertex(k, V, S)  # выбираем вершину с наибольшей пропускной способностью
            if j == -1:  # если следующих вершин нет
                if k == init:  # и мы на истоке
                    break  # завершаем поиск маршрутов
                else:  # иначе переходим к предыдущей вершине
                    k = T.pop()[2]
                    continue
            c = V[k][j][0] if V[k][j][2] == 1 else V[k][j][1]  # определяем текущий поток
            T.append((c, j, k))  # добавляем маршрут
            S.add(j)  # запоминаем вершину как просмотренную

            # если дошли до стока
            if j == end:
                f.append(get_max_flow(T)) # находим макс. пропусную способность маршрута
                updateV(V, T, f[-1])  # обновляем веса дуг
                break
            k = j


    F = sum(f)
    print(f'Максимальный поток в графе: {F} ед.')



